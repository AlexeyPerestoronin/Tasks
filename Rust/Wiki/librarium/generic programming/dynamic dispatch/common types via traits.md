[← back to library](../../../librarium.md)

В Rust, trait объекты позволяют использовать динамическое диспетчеризацию для работы с типами, которые реализуют определённый трейт, без необходимости знать конкретный тип во время компиляции.  

Это полезно, когда вам нужно работать с разными типами, реализующими один и тот же трейт, но вы не хотите использовать обобщённые типы:  
1. **Использование trait объектов в качестве аргументов функций**:
    Чтобы использовать trait объект в качестве аргумента функции, вы можете использовать синтаксис `&dyn Trait` или `Box<dyn Trait>`:
    ```rust
    trait Draw {
        fn draw(&self);
    }

    struct Circle;
    struct Square;

    impl Draw for Circle {
        fn draw(&self) {
            println!("Drawing a circle");
        }
    }

    impl Draw for Square {
        fn draw(&self) {
            println!("Drawing a square");
        }
    }

    fn draw_shape(shape: &dyn Draw) {
        shape.draw();
    }

    fn main() {
        let circle = Circle;
        let square = Square;

        draw_shape(&circle);
        draw_shape(&square);
    }
    ```
    В этом примере функция draw_shape принимает ссылку на trait объект `&dyn Draw`, что позволяет ей работать с любым типом, который реализует трейт `Draw`.

***

Trait объекты предоставляют гибкость в работе с различными типами, реализующими один и тот же трейт, и полезны в ситуациях, когда обобщённые типы не подходят:
1. **Использование trait объектов в контейнерах**:  
    Trait объекты также могут использоваться в контейнерах, таких как векторы, для хранения различных типов, реализующих один и тот же трейт.  
    Для этого обычно используется `Box<dyn Trait>`, так как объекты в контейнерах должны иметь фиксированный размер:  
    ```rust
    fn main() {
        let shapes: Vec<Box<dyn Draw>> = vec![
            Box::new(Circle),
            Box::new(Square),
        ];

        for shape in shapes {
            shape.draw();
        }
    }
    ```
    В этом примере вектор shapes содержит объекты `Circle` и `Square`, упакованные в `Box<dyn Draw>`.  
    Это позволяет хранить их в одном векторе и вызывать метод `draw` для каждого элемента.

***

**Важные моменты**:  
1. 
 style="text-decoration: underline;">Динамическая диспетчеризация</span>:  
    Использование trait объектов приводит к динамической диспетчеризации, что может иметь небольшие накладные расходы по сравнению с обобщёнными типами, которые используют статическую диспетчеризацию.

0. <span style="text-decoration: underline;">Объекты должны быть безопасными для объектов</span>:  
    Трейты, используемые в качестве trait объектов, не могут иметь методы, возвращающие Self, или использовать обобщённые параметры. Это связано с тем, что конкретный тип Self неизвестен во время выполнения.

0. <span style="text-decoration: underline;">Жизненные циклы</span>:  
    При использовании ссылок на trait объекты, таких как` &dyn Trait`, необходимо учитывать жизненные циклы, чтобы избежать проблем с заимствованием.