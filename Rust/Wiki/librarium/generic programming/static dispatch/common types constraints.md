[← back to library](../../../librarium.md)

В Rust существует несколько способов задания ограничений для обобщённых типов, чтобы обеспечить выполнение определённых условий для этих типов. Эти ограничения задаются с помощью трейтов и называются ограничениями трейтов.  

Вот основные способы задания таких ограничений:  
1. **Ограничения с помощью трейтов**:  
    Вы можете ограничить обобщённый тип, указав, что он должен реализовывать определённый трейт.  
    Это делается с помощью двоеточия после имени обобщённого типа:
    ```rust
    fn print_display<T: std::fmt::Display>(item: T) {
        println!("{}", item);
    }
    ```
    В этом примере `T` должен реализовывать трейт `Display`, чтобы его можно было передать в функцию `print_display`.

0. **Множественные ограничения**:  
    Вы можете задать несколько ограничений для одного обобщённого типа, используя оператор +:
    ```rust
    fn compare_and_display<T: PartialOrd + std::fmt::Display>(a: T, b: T) {
        if a > b {
            println!("{} is greater than {}", a, b);
        } else {
            println!("{} is not greater than {}", a, b);
        }
    }
    ```
    Здесь `T` должен реализовывать как `PartialOrd`, так и `Display`.

0. **Где-ограничения (where clauses)**:  
    Для более сложных случаев, когда ограничения становятся громоздкими, можно использовать where-ограничения.  
    Это позволяет вынести ограничения из сигнатуры функции, улучшая читаемость:  
    ```rust
    fn some_function<T, U>(t: T, u: U) 
    where
        T: std::fmt::Display + Clone,
        U: std::fmt::Debug,
    {
        println!("t: {}, u: {:?}", t, u);
    }
    ```
    Здесь `T` должен реализовывать `Display` и `Clone`, а `U` — Debug.

0. **Ограничения на уровне структуры или перечисления**:  
    Вы можете задавать ограничения для обобщённых типов в структурах и перечислениях:  
    ```rust
    struct Pair<T: PartialOrd> {
        first: T,
        second: T,
    }

    impl<T: PartialOrd> Pair<T> {
        fn new(first: T, second: T) -> Self {
            Self { first, second }
        }
    }
    ```
    В этом примере структура `Pair` ограничивает `T` типами, которые реализуют `PartialOrd`.

Эти методы позволяют точно контролировать, какие типы могут использоваться с обобщёнными функциями, структурами и перечислениями, обеспечивая безопасность и корректность кода.