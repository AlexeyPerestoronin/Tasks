# Замыкания (closures):
## `Fn`
Замыкание, которое захватывает переменные из окружающего контекста по неизменяемой ссылке.  
Это наиболее ограничительный тип замыкания, так как он не позволяет изменять захваченные переменные.
```rust
fn call_fn<F>(f: F)
where
    F: Fn(),
{
    f();
    f(); // Можно вызвать несколько раз
}

fn main() {
    let x = 5;
    let print_x = || println!("x is {}", x);

    call_fn(print_x);
}
```

## `FnMut`
Замыкание, которое захватывает переменные по изменяемой ссылке.  
Это позволяет изменять захваченные переменные, но требует, чтобы замыкание было вызываемо как изменяемое.
```rust
fn call_fn_mut<F>(mut f: F)
where
    F: FnMut(),
{
    f();
    f(); // Можно вызвать несколько раз
}

fn main() {
    let mut x = 5;
    let mut increment_x = || {
        x += 1;
        println!("x is {}", x);
    };

    call_fn_mut(increment_x);
}
```

## `FnOnce`
Замыкание, которое захватывает переменные по значению.  
Это единственный тип замыкания, который может захватывать владение переменными, и, следовательно, может быть вызвано только один раз, так как после вызова оно теряет владение захваченными переменными.
> данный тип замыкания используется при создании потоков через `std::thread::spawn`
```rust
fn call_fn_once<F>(f: F)
where
    F: FnOnce(),
{
    f(); // Можно вызвать только один раз
}

fn main() {
    let x = String::from("Hello");
    let consume_x = || {
        println!("x is {}", x);
        // x будет перемещен сюда и больше не будет доступен
    };

    call_fn_once(consume_x);
    // println!("x is {}", x); // Ошибка: x больше не доступен
}
```

## Параметризация:
Чтобы параметризировать замыкание `FnOnce` (или любое другое замыкание) и передавать ему переменные определенного типа при вызове, необходимо указать типы аргументов, которые замыкание будет принимать.
> можно использовать обобщенные параметры (generics).
```rust
fn call_fn_once_with_args<F, A>(f: F, arg: A)
where
    F: FnOnce(A),
{
    f(arg);
}

fn main() {
    let x = String::from("Hello");
    let print_message = |message: String| {
        println!("Message: {}", message);
    };

    call_fn_once_with_args(print_message, x);
    // После вызова print_message, x больше не доступен
}
```